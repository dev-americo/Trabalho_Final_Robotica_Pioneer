% Codigo locomocao robo com rodas diferencial 

%Limpando as variáveis
clear all 
close all 
clc 

% Parametros do robo Pioneer 
v_r_max = 01.5;   % velocidade maxima da roda direita m/s
v_l_max = 01.5;   % velocidade maxima da roda esquerda m/s 
W = 0.381;        % distancia entre as rodas em m
% Incializando as variaveis 
delta_t = 0.1;  


% Equacoes basicas de movimento do robo
v_max = (1/2)*(v_r_max+v_l_max);        % velocidade a frente, eixo x 
theta_dot_max = (v_r_max - v_l_max)/W;  % velocidade angular 
% x_dot_max = v_max*cos(theta);               % velocidade em x
% y_dot_max = v_max*sen(theta);               % velocidade em y 

% Pontos inicial e final do robo 
% pose_inicial = [x0,y0,theta0];              % pose inicial do robo 
% pose_final = [xFinal, yFinal,thetaFinal];    % pose final do robo 
pose_inicial = [0,0,0];              % pose inicial do robo 
ponto_final = [2,3];                % ponto final do robo

% Calculos para encontrar a diferenca x,y,theta inicial final 
% por enquanto so funciona se theta0 = 0 - melhorar depois! 
delta_x = ponto_final(1,1) - pose_inicial(1,1); 
delta_y = ponto_final(1,2) - pose_inicial(1,2);
theta_alinhamento = atan2d(delta_y,delta_x);    % arco tangente em graus

% Codigo para o robo andar pra frente no eixo x 
k = 1;                                          % inicializando o contador de tempo discreto 
% x(k) = pose_inicial(1,1); 
% y(k) = pose_inicial(1,2);
% theta(k) = pose_inicial(1,3); 
% pose(k,1:2) = ponto_inicial; % transposta 
pose(k,:) = pose_inicial; 
erro(k,1:2) = ponto_final - pose(k,1:2); 
erro(k,3) = theta_alinhamento - pose(k,3); 

% erro_x(k) = pose_final(1,1) - x(k); 
% erro_alinhamento(k) = theta_alinhamento - theta(k); 

% tratanto primeiro o erro de alinhamento
% while erro_alinhamento(k) > 0.1 % por hora so funciona para positivo 
while erro(k,3) > 1 % por hora so funciona para positivo 
    
    delta_v = v_r_max-v_l_max; % esse funciona para positivo
    v = (1/2)*delta_v; 
    theta_ponto = (v_r_max+v_l_max)/W; 

    pose(k+1,1) = pose(k,1) + cosd(pose(k,3))*(v*delta_t);
    pose(k+1,2) = pose(k,2) + sind(pose(k,3))*(v*delta_t);
    pose(k+1,3) = pose(k,3) + theta_ponto*delta_t; 

    erro(k+1,1:2) = ponto_final - pose(k+1,1:2); 
    erro(k+1,3) = theta_alinhamento - pose(k+1,3); 
    % erro_x(k+1) = pose_final(1,1) - x(k+1);
    % erro_alinhamento(k+1) = theta_alinhamento - theta(k);

    %grafico incremental
    cla;    
    hold on 
    quiver(pose(k,1),pose(k,2),W*cosd(pose(k,3)),W*sind(pose(k,3)),0,'b'); 
    quiver(pose(k,1),pose(k,2),-W*sind(pose(k,3)),W*cosd(pose(k,3)),0,'r'); 
    xlim([-1 4]),ylim([-1 4]);
    grid on 
    pause(0.1)

    k = k+1; 
end

% Agora resolvendo para a posicao: o ponto final agora deve ser escrito em
% termos da pose atual, chamamos de pose_theta 

% Matriz posição final
P_final_homogeneo = [ponto_final(1); ponto_final(2); 1];

% Posição do robô (após giro)
x_robo = pose(k,1);
y_robo = pose(k,2);
theta_robo = pose(k,3);

% Tranformação homogêna (verifica o ponto no X do robô)
T_inicial = [ cosd(theta_robo), -sind(theta_robo), x_robo;
                sind(theta_robo),  cosd(theta_robo), y_robo;
                0,                 0,                1       ];

% Inverte a matriz            
T_inverso = inv(T_inicial); 

%Encontra Ponto P em X do robô
P_alvo = T_inverso * P_final_homogeneo;
erro_x_atual = P_alvo(1); % erro em X


while erro_x_atual > 0.1 
    
    % Velocidade
    theta_ponto= (v_r_max-v_l_max)/W; 
    
    % atualização das poses
    pose(k+1,1) = pose(k,1) + cosd(pose(k,3)) * (v_max * delta_t);
    pose(k+1,2) = pose(k,2) + sind(pose(k,3)) * (v_max * delta_t);
    pose(k+1,3) = pose(k,3) + theta_ponto * delta_t; 

    % icrementando pose
    x_robo_novo = pose(k+1,1);
    y_robo_novo = pose(k+1,2);
    theta_robo_novo = pose(k+1,3);
    
    % transformação homogenea
    T_inicial_novo = [ cosd(theta_robo_novo), -sind(theta_robo_novo), x_robo_novo;
                      sind(theta_robo_novo),  cosd(theta_robo_novo), y_robo_novo;
                      0,                 0,                1       ];
    
    % inversa
    T_inverso_novo = inv(T_inicial_novo); 

    
    P_alvo_novo = T_inverso_novo * P_final_homogeneo;
    
    erro_x_atual = P_alvo_novo(1); 
    
    k = k+1; 

    %Grafico
    cla;    
    hold on 

    quiver(pose(k,1),pose(k,2),W*cosd(pose(k,3)),W*sind(pose(k,3)),0,'b'); 
    quiver(pose(k,1),pose(k,2),-W*sind(pose(k,3)),W*cosd(pose(k,3)),0,'r'); 
    xlim([-1 4]),ylim([-1 4]);
    grid on 
    pause(0.1)
    
end